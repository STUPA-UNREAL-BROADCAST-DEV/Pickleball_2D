<!DOCTYPE html>
<html lang="en" class="overlay-page">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Single Player Metric Overlay</title>
  <link rel="stylesheet" href="/styles.css" />
</head>

<body class="overlay overlay-metrics">
  <div class="metrics-card board" id="singlePlayerBoard" data-overlay="singleplayer">
    <div class="metrics-card__header" id="metricTitle">TOTAL POINTS WON SO FAR</div>

    <div class="metrics-card__row">
      <div class="metrics-card__label" id="playerName">Player A</div>
      <div class="metrics-card__value" id="playerValue">0</div>
    </div>
  </div>

  <script>
    const METRICS = {
      total_points_won: {
        title: 'Total Points Won',
        keyA: 'player_a_total_points_won',
        keyB: 'player_b_total_points_won'
      },
      total_serves_done: {
        title: 'Total Serves Done',
        keyA: 'player_a_total_serves_done',
        keyB: 'player_b_total_serves_done'
      },
      points_on_serve: {
        title: 'Points on Serve',
        keyA: 'player_a_points_on_serve',
        keyB: 'player_b_points_on_serve'
      },
      forced_errors: {
        title: 'Forced Errors',
        keyA: 'player_a_forced_errors',
        keyB: 'player_b_forced_errors'
      },
      unforced_errors: {
        title: 'Unforced Errors',
        keyA: 'player_a_unforced_errors',
        keyB: 'player_b_unforced_errors'
      }
    };

    const board = document.getElementById('singlePlayerBoard');
    const metricTitle = document.getElementById('metricTitle');
    const playerNameEl = document.getElementById('playerName');
    const playerValueEl = document.getElementById('playerValue');

    let currentMetricKey = 'total_points_won';
    let currentPlayer = 'a';
    let lastValue = undefined;
    let lastName = '';
    let lastVisibility;
    let lastMetricTitle;

    async function fetchState() {
      try {
        const response = await fetch('/api/state', { cache: 'no-store' });
        if (!response.ok) {
          throw new Error('Failed to fetch state');
        }
        const data = await response.json();
        render(data);
      } catch (error) {
        console.error(error);
      }
    }

    function render(data) {
      const metricKey = METRICS[data.singleplayer_metric] ? data.singleplayer_metric : 'total_points_won';
      const player = data.singleplayer_player === 'b' ? 'b' : 'a';
      
      if (metricKey !== currentMetricKey || player !== currentPlayer) {
        currentMetricKey = metricKey;
        currentPlayer = player;
        lastValue = undefined;
        lastName = '';
        lastMetricTitle = undefined;
      }

      const metric = METRICS[currentMetricKey];
      const isVisible = data.singleplayer_visible !== false;

      if (isVisible !== lastVisibility) {
        board.classList.toggle('is-hidden', !isVisible);
        if (isVisible) {
          lastValue = undefined;
          lastName = '';
          triggerAnimation();
        }
        lastVisibility = isVisible;
      }

      const headerText = `${metric.title.toUpperCase()} SO FAR`;
      
      if (headerText !== lastMetricTitle) {
        metricTitle.textContent = headerText;
        lastMetricTitle = headerText;
      }

      const playerName = currentPlayer === 'b' 
        ? (data.player_b_name || 'Player B')
        : (data.player_a_name || 'Player A');

      const valueKey = currentPlayer === 'b' ? metric.keyB : metric.keyA;
      const value = parseNumeric(data[valueKey]);

      if (lastName !== playerName) {
        playerNameEl.textContent = playerName;
        lastName = playerName;
      }

      if (lastValue !== value) {
        animateNumber(playerValueEl, lastValue ?? 0, value);
        lastValue = value;
      }

      if ((lastValue !== value || lastName !== playerName) && lastVisibility !== false) {
        triggerAnimation();
      }

      playerValueEl.textContent = Math.round(value);
    }

    function parseNumeric(value) {
      const num = Number(value);
      return Number.isFinite(num) ? Math.round(num) : 0;
    }

    function animateNumber(el, fromValue, toValue) {
      const start = Number.isFinite(fromValue) ? fromValue : 0;
      const end = Number.isFinite(toValue) ? toValue : 0;
      const duration = 600;
      const startTime = performance.now();

      function frame(now) {
        const progress = Math.min(1, (now - startTime) / duration);
        const eased = easeOutCubic(progress);
        const current = Math.round(start + (end - start) * eased);
        el.textContent = current;
        if (progress < 1) {
          requestAnimationFrame(frame);
        }
      }

      requestAnimationFrame(frame);
    }

    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    function triggerAnimation() {
      board.classList.remove('animate');
      void board.offsetWidth;
      board.classList.add('animate');
    }

    fetchState();
    setInterval(fetchState, 300);
  </script>
</body>

</html>

